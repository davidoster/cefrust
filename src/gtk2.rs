/* automatically generated by rust-bindgen */

#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]

pub type guint8 = ::std::os::raw::c_uchar;
pub type guint16 = ::std::os::raw::c_ushort;
pub type guint32 = ::std::os::raw::c_uint;
pub type gint64 = ::std::os::raw::c_long;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gsize = ::std::os::raw::c_ulong;
pub type gchar = ::std::os::raw::c_char;
pub type glong = ::std::os::raw::c_long;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type gulong = ::std::os::raw::c_ulong;
pub type guint = ::std::os::raw::c_uint;
pub type gfloat = f32;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GArray {
    pub data: *mut gchar,
    pub len: guint,
}
#[test]
fn bindgen_test_layout__GArray() {
    assert_eq!(::std::mem::size_of::<_GArray>() , 16usize);
    assert_eq!(::std::mem::align_of::<_GArray>() , 8usize);
}
impl Clone for _GArray {
    fn clone(&self) -> Self { *self }
}
pub use self::_GArray as GArray;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GData {
    pub _address: u8,
}
impl Clone for _GData {
    fn clone(&self) -> Self { *self }
}
pub use self::_GData as GData;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GSList {
    pub data: gpointer,
    pub next: *mut GSList,
}
#[test]
fn bindgen_test_layout__GSList() {
    assert_eq!(::std::mem::size_of::<_GSList>() , 16usize);
    assert_eq!(::std::mem::align_of::<_GSList>() , 8usize);
}
impl Clone for _GSList {
    fn clone(&self) -> Self { *self }
}
pub use self::_GSList as GSList;
pub type GType = gsize;
/**
 * GValue:
 * 
 * An opaque structure used to hold different types of values.
 * The data within the structure has protected scope: it is accessible only
 * to functions within a #GTypeValueTable structure, or implementations of
 * the g_value_*() API. That is, code portions which implement new fundamental
 * types.
 * #GValue users cannot make any assumptions about how data is stored
 * within the 2 element @data union, and the @g_type member should
 * only be accessed through the G_VALUE_TYPE() macro.
 */
#[repr(C)]
#[derive(Copy)]
pub struct _GValue {
    pub g_type: GType,
    pub data: [_GValue__bindgen_ty_1; 2usize],
}
#[repr(C)]
#[derive(Copy)]
pub union _GValue__bindgen_ty_1 {
    pub v_int: gint,
    pub v_uint: guint,
    pub v_long: glong,
    pub v_ulong: gulong,
    pub v_int64: gint64,
    pub v_uint64: guint64,
    pub v_float: gfloat,
    pub v_double: gdouble,
    pub v_pointer: gpointer,
}
#[test]
fn bindgen_test_layout__GValue__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_GValue__bindgen_ty_1>() , 8usize);
    assert_eq!(::std::mem::align_of::<_GValue__bindgen_ty_1>() , 8usize);
}
impl Clone for _GValue__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__GValue() {
    assert_eq!(::std::mem::size_of::<_GValue>() , 24usize);
    assert_eq!(::std::mem::align_of::<_GValue>() , 8usize);
}
impl Clone for _GValue {
    fn clone(&self) -> Self { *self }
}
pub use self::_GValue as GValue;
/**
 * GTypeClass:
 * 
 * An opaque structure used as the base of all classes.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GTypeClass {
    pub g_type: GType,
}
#[test]
fn bindgen_test_layout__GTypeClass() {
    assert_eq!(::std::mem::size_of::<_GTypeClass>() , 8usize);
    assert_eq!(::std::mem::align_of::<_GTypeClass>() , 8usize);
}
impl Clone for _GTypeClass {
    fn clone(&self) -> Self { *self }
}
pub use self::_GTypeClass as GTypeClass;
/**
 * GTypeInstance:
 * 
 * An opaque structure used as the base of all type instances.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GTypeInstance {
    pub g_class: *mut GTypeClass,
}
#[test]
fn bindgen_test_layout__GTypeInstance() {
    assert_eq!(::std::mem::size_of::<_GTypeInstance>() , 8usize);
    assert_eq!(::std::mem::align_of::<_GTypeInstance>() , 8usize);
}
impl Clone for _GTypeInstance {
    fn clone(&self) -> Self { *self }
}
pub use self::_GTypeInstance as GTypeInstance;
/**
 * GClosure:
 * @in_marshal: Indicates whether the closure is currently being invoked with 
 *  g_closure_invoke()
 * @is_invalid: Indicates whether the closure has been invalidated by 
 *  g_closure_invalidate()
 * 
 * A #GClosure represents a callback supplied by the programmer.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GClosure {
    pub _bitfield_1: u32,
    pub marshal: ::std::option::Option<unsafe extern "C" fn(closure:
                                                                *mut GClosure,
                                                            return_value:
                                                                *mut GValue,
                                                            n_param_values:
                                                                guint,
                                                            param_values:
                                                                *const GValue,
                                                            invocation_hint:
                                                                gpointer,
                                                            marshal_data:
                                                                gpointer)>,
    pub data: gpointer,
    pub notifiers: *mut GClosureNotifyData,
}
#[test]
fn bindgen_test_layout__GClosure() {
    assert_eq!(::std::mem::size_of::<_GClosure>() , 32usize);
    assert_eq!(::std::mem::align_of::<_GClosure>() , 8usize);
}
impl Clone for _GClosure {
    fn clone(&self) -> Self { *self }
}
impl _GClosure {
    #[inline]
    pub fn ref_count(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32767usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_ref_count(&mut self, val: guint) {
        self._bitfield_1 &= !(32767usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (32767usize as u32);
    }
    #[inline]
    pub fn meta_marshal_nouse(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_meta_marshal_nouse(&mut self, val: guint) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn n_guards(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_n_guards(&mut self, val: guint) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn n_fnotifiers(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (393216usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_n_fnotifiers(&mut self, val: guint) {
        self._bitfield_1 &= !(393216usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (393216usize as u32);
    }
    #[inline]
    pub fn n_inotifiers(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (133693440usize as u32)) >> 19u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_n_inotifiers(&mut self, val: guint) {
        self._bitfield_1 &= !(133693440usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (133693440usize as u32);
    }
    #[inline]
    pub fn in_inotify(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (134217728usize as u32)) >> 27u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_in_inotify(&mut self, val: guint) {
        self._bitfield_1 &= !(134217728usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 27u32) & (134217728usize as u32);
    }
    #[inline]
    pub fn floating(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (268435456usize as u32)) >> 28u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_floating(&mut self, val: guint) {
        self._bitfield_1 &= !(268435456usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 28u32) & (268435456usize as u32);
    }
    #[inline]
    pub fn derivative_flag(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (536870912usize as u32)) >> 29u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_derivative_flag(&mut self, val: guint) {
        self._bitfield_1 &= !(536870912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (536870912usize as u32);
    }
    #[inline]
    pub fn in_marshal(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1073741824usize as u32)) >> 30u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_in_marshal(&mut self, val: guint) {
        self._bitfield_1 &= !(1073741824usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (1073741824usize as u32);
    }
    #[inline]
    pub fn is_invalid(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (2147483648usize as u32)) >> 31u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_is_invalid(&mut self, val: guint) {
        self._bitfield_1 &= !(2147483648usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 31u32) & (2147483648usize as u32);
    }
}
pub use self::_GClosure as GClosure;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GClosureNotifyData {
    pub data: gpointer,
    pub notify: GClosureNotify,
}
#[test]
fn bindgen_test_layout__GClosureNotifyData() {
    assert_eq!(::std::mem::size_of::<_GClosureNotifyData>() , 16usize);
    assert_eq!(::std::mem::align_of::<_GClosureNotifyData>() , 8usize);
}
impl Clone for _GClosureNotifyData {
    fn clone(&self) -> Self { *self }
}
pub use self::_GClosureNotifyData as GClosureNotifyData;
/**
 * GCallback:
 * 
 * The type used for callback functions in structure definitions and function 
 * signatures. This doesn't mean that all callback functions must take no 
 * parameters and return void. The required signature of a callback function 
 * is determined by the context in which is used (e.g. the signal to which it 
 * is connected). Use G_CALLBACK() to cast the callback function to a #GCallback. 
 */
pub type GCallback = ::std::option::Option<unsafe extern "C" fn()>;
/**
 * GClosureNotify:
 * @data: data specified when registering the notification callback
 * @closure: the #GClosure on which the notification is emitted
 * 
 * The type used for the various notification callbacks which can be registered
 * on closures.
 */
pub type GClosureNotify =
    ::std::option::Option<unsafe extern "C" fn(data: gpointer,
                                               closure: *mut GClosure)>;
pub const G_CONNECT_AFTER: _bindgen_ty_99 = _bindgen_ty_99::G_CONNECT_AFTER;
pub const G_CONNECT_SWAPPED: _bindgen_ty_99 =
    _bindgen_ty_99::G_CONNECT_SWAPPED;
#[repr(u32)]
/**
 * GConnectFlags:
 * @G_CONNECT_AFTER: whether the handler should be called before or after the 
 *  default handler of the signal.
 * @G_CONNECT_SWAPPED: whether the instance and data should be swapped when
 *  calling the handler; see g_signal_connect_swapped() for an example.
 * 
 * The connection flags are used to specify the behaviour of a signal's 
 * connection.
 */
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_99 { G_CONNECT_AFTER = 1, G_CONNECT_SWAPPED = 2, }
pub use self::_bindgen_ty_99 as GConnectFlags;
extern "C" {
    pub fn g_signal_connect_data(instance: gpointer,
                                 detailed_signal: *const gchar,
                                 c_handler: GCallback, data: gpointer,
                                 destroy_data: GClosureNotify,
                                 connect_flags: GConnectFlags) -> gulong;
}
/**
 * GObject:
 * 
 * All the fields in the GObject structure are private 
 * to the #GObject implementation and should never be accessed directly.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GObject {
    pub g_type_instance: GTypeInstance,
    pub ref_count: guint,
    pub qdata: *mut GData,
}
#[test]
fn bindgen_test_layout__GObject() {
    assert_eq!(::std::mem::size_of::<_GObject>() , 24usize);
    assert_eq!(::std::mem::align_of::<_GObject>() , 8usize);
}
impl Clone for _GObject {
    fn clone(&self) -> Self { *self }
}
pub use self::_GObject as GObject;
pub use self::_GObject as GInitiallyUnowned;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _cairo_font_options {
    pub _address: u8,
}
impl Clone for _cairo_font_options {
    fn clone(&self) -> Self { *self }
}
/**
 * cairo_font_options_t:
 *
 * An opaque structure holding all options that are used when
 * rendering fonts.
 *
 * Individual features of a #cairo_font_options_t can be set or
 * accessed using functions named
 * <function>cairo_font_options_set_<emphasis>feature_name</emphasis>()</function> and
 * <function>cairo_font_options_get_<emphasis>feature_name</emphasis>()</function>, like
 * cairo_font_options_set_antialias() and
 * cairo_font_options_get_antialias().
 *
 * New features may be added to a #cairo_font_options_t in the
 * future.  For this reason, cairo_font_options_copy(),
 * cairo_font_options_equal(), cairo_font_options_merge(), and
 * cairo_font_options_hash() should be used to copy, check
 * for equality, merge, or compute a hash value of
 * #cairo_font_options_t objects.
 *
 * Since: 1.0
 **/
pub use self::_cairo_font_options as cairo_font_options_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _PangoFontDescription {
    pub _address: u8,
}
impl Clone for _PangoFontDescription {
    fn clone(&self) -> Self { *self }
}
/**
 * PangoFontDescription:
 *
 * The #PangoFontDescription structure represents the description
 * of an ideal font. These structures are used both to list
 * what fonts are available on the system and also for specifying
 * the characteristics of a font to load.
 */
pub use self::_PangoFontDescription as PangoFontDescription;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkRectangle {
    pub x: gint,
    pub y: gint,
    pub width: gint,
    pub height: gint,
}
#[test]
fn bindgen_test_layout__GdkRectangle() {
    assert_eq!(::std::mem::size_of::<_GdkRectangle>() , 16usize);
    assert_eq!(::std::mem::align_of::<_GdkRectangle>() , 4usize);
}
impl Clone for _GdkRectangle {
    fn clone(&self) -> Self { *self }
}
pub use self::_GdkRectangle as GdkRectangle;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkColor {
    pub pixel: guint32,
    pub red: guint16,
    pub green: guint16,
    pub blue: guint16,
}
#[test]
fn bindgen_test_layout__GdkColor() {
    assert_eq!(::std::mem::size_of::<_GdkColor>() , 12usize);
    assert_eq!(::std::mem::align_of::<_GdkColor>() , 4usize);
}
impl Clone for _GdkColor {
    fn clone(&self) -> Self { *self }
}
pub use self::_GdkColor as GdkColor;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkColormap {
    pub parent_instance: GObject,
    pub size: gint,
    pub colors: *mut GdkColor,
    pub visual: *mut GdkVisual,
    pub windowing_data: gpointer,
}
#[test]
fn bindgen_test_layout__GdkColormap() {
    assert_eq!(::std::mem::size_of::<_GdkColormap>() , 56usize);
    assert_eq!(::std::mem::align_of::<_GdkColormap>() , 8usize);
}
impl Clone for _GdkColormap {
    fn clone(&self) -> Self { *self }
}
pub use self::_GdkColormap as GdkColormap;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkFont {
    pub type_: GdkFontType,
    pub ascent: gint,
    pub descent: gint,
}
#[test]
fn bindgen_test_layout__GdkFont() {
    assert_eq!(::std::mem::size_of::<_GdkFont>() , 12usize);
    assert_eq!(::std::mem::align_of::<_GdkFont>() , 4usize);
}
impl Clone for _GdkFont {
    fn clone(&self) -> Self { *self }
}
pub use self::_GdkFont as GdkFont;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkGC {
    pub parent_instance: GObject,
    pub clip_x_origin: gint,
    pub clip_y_origin: gint,
    pub ts_x_origin: gint,
    pub ts_y_origin: gint,
    pub colormap: *mut GdkColormap,
}
#[test]
fn bindgen_test_layout__GdkGC() {
    assert_eq!(::std::mem::size_of::<_GdkGC>() , 48usize);
    assert_eq!(::std::mem::align_of::<_GdkGC>() , 8usize);
}
impl Clone for _GdkGC {
    fn clone(&self) -> Self { *self }
}
pub use self::_GdkGC as GdkGC;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkVisual {
    pub parent_instance: GObject,
    pub type_: GdkVisualType,
    pub depth: gint,
    pub byte_order: GdkByteOrder,
    pub colormap_size: gint,
    pub bits_per_rgb: gint,
    pub red_mask: guint32,
    pub red_shift: gint,
    pub red_prec: gint,
    pub green_mask: guint32,
    pub green_shift: gint,
    pub green_prec: gint,
    pub blue_mask: guint32,
    pub blue_shift: gint,
    pub blue_prec: gint,
}
#[test]
fn bindgen_test_layout__GdkVisual() {
    assert_eq!(::std::mem::size_of::<_GdkVisual>() , 80usize);
    assert_eq!(::std::mem::align_of::<_GdkVisual>() , 8usize);
}
impl Clone for _GdkVisual {
    fn clone(&self) -> Self { *self }
}
pub use self::_GdkVisual as GdkVisual;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkDrawable {
    pub parent_instance: GObject,
}
#[test]
fn bindgen_test_layout__GdkDrawable() {
    assert_eq!(::std::mem::size_of::<_GdkDrawable>() , 24usize);
    assert_eq!(::std::mem::align_of::<_GdkDrawable>() , 8usize);
}
impl Clone for _GdkDrawable {
    fn clone(&self) -> Self { *self }
}
pub use self::_GdkDrawable as GdkDrawable;
pub use self::_GdkDrawable as GdkPixmap;
pub use self::_GdkDrawable as GdkWindow;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GdkScreen {
    pub parent_instance: GObject,
    pub _bitfield_1: u8,
    pub normal_gcs: [*mut GdkGC; 32usize],
    pub exposure_gcs: [*mut GdkGC; 32usize],
    pub subwindow_gcs: [*mut GdkGC; 32usize],
    pub font_options: *mut cairo_font_options_t,
    pub resolution: f64,
}
#[test]
fn bindgen_test_layout__GdkScreen() {
    assert_eq!(::std::mem::size_of::<_GdkScreen>() , 816usize);
    assert_eq!(::std::mem::align_of::<_GdkScreen>() , 8usize);
}
impl Clone for _GdkScreen {
    fn clone(&self) -> Self { *self }
}
impl _GdkScreen {
    #[inline]
    pub fn closed(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_closed(&mut self, val: guint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
}
pub use self::_GdkScreen as GdkScreen;
pub const GDK_LSB_FIRST: _bindgen_ty_209 = _bindgen_ty_209::GDK_LSB_FIRST;
pub const GDK_MSB_FIRST: _bindgen_ty_209 = _bindgen_ty_209::GDK_MSB_FIRST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_209 { GDK_LSB_FIRST = 0, GDK_MSB_FIRST = 1, }
pub use self::_bindgen_ty_209 as GdkByteOrder;
pub const GDK_SHIFT_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_SHIFT_MASK;
pub const GDK_LOCK_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_LOCK_MASK;
pub const GDK_CONTROL_MASK: _bindgen_ty_210 =
    _bindgen_ty_210::GDK_CONTROL_MASK;
pub const GDK_MOD1_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_MOD1_MASK;
pub const GDK_MOD2_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_MOD2_MASK;
pub const GDK_MOD3_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_MOD3_MASK;
pub const GDK_MOD4_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_MOD4_MASK;
pub const GDK_MOD5_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_MOD5_MASK;
pub const GDK_BUTTON1_MASK: _bindgen_ty_210 =
    _bindgen_ty_210::GDK_BUTTON1_MASK;
pub const GDK_BUTTON2_MASK: _bindgen_ty_210 =
    _bindgen_ty_210::GDK_BUTTON2_MASK;
pub const GDK_BUTTON3_MASK: _bindgen_ty_210 =
    _bindgen_ty_210::GDK_BUTTON3_MASK;
pub const GDK_BUTTON4_MASK: _bindgen_ty_210 =
    _bindgen_ty_210::GDK_BUTTON4_MASK;
pub const GDK_BUTTON5_MASK: _bindgen_ty_210 =
    _bindgen_ty_210::GDK_BUTTON5_MASK;
pub const GDK_SUPER_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_SUPER_MASK;
pub const GDK_HYPER_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_HYPER_MASK;
pub const GDK_META_MASK: _bindgen_ty_210 = _bindgen_ty_210::GDK_META_MASK;
pub const GDK_RELEASE_MASK: _bindgen_ty_210 =
    _bindgen_ty_210::GDK_RELEASE_MASK;
pub const GDK_MODIFIER_MASK: _bindgen_ty_210 =
    _bindgen_ty_210::GDK_MODIFIER_MASK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_210 {
    GDK_SHIFT_MASK = 1,
    GDK_LOCK_MASK = 2,
    GDK_CONTROL_MASK = 4,
    GDK_MOD1_MASK = 8,
    GDK_MOD2_MASK = 16,
    GDK_MOD3_MASK = 32,
    GDK_MOD4_MASK = 64,
    GDK_MOD5_MASK = 128,
    GDK_BUTTON1_MASK = 256,
    GDK_BUTTON2_MASK = 512,
    GDK_BUTTON3_MASK = 1024,
    GDK_BUTTON4_MASK = 2048,
    GDK_BUTTON5_MASK = 4096,
    GDK_SUPER_MASK = 67108864,
    GDK_HYPER_MASK = 134217728,
    GDK_META_MASK = 268435456,
    GDK_RELEASE_MASK = 1073741824,
    GDK_MODIFIER_MASK = 1543512063,
}
pub use self::_bindgen_ty_210 as GdkModifierType;
pub const GDK_FONT_FONT: _bindgen_ty_247 = _bindgen_ty_247::GDK_FONT_FONT;
pub const GDK_FONT_FONTSET: _bindgen_ty_247 =
    _bindgen_ty_247::GDK_FONT_FONTSET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_247 { GDK_FONT_FONT = 0, GDK_FONT_FONTSET = 1, }
pub use self::_bindgen_ty_247 as GdkFontType;
pub const GDK_VISUAL_STATIC_GRAY: _bindgen_ty_261 =
    _bindgen_ty_261::GDK_VISUAL_STATIC_GRAY;
pub const GDK_VISUAL_GRAYSCALE: _bindgen_ty_261 =
    _bindgen_ty_261::GDK_VISUAL_GRAYSCALE;
pub const GDK_VISUAL_STATIC_COLOR: _bindgen_ty_261 =
    _bindgen_ty_261::GDK_VISUAL_STATIC_COLOR;
pub const GDK_VISUAL_PSEUDO_COLOR: _bindgen_ty_261 =
    _bindgen_ty_261::GDK_VISUAL_PSEUDO_COLOR;
pub const GDK_VISUAL_TRUE_COLOR: _bindgen_ty_261 =
    _bindgen_ty_261::GDK_VISUAL_TRUE_COLOR;
pub const GDK_VISUAL_DIRECT_COLOR: _bindgen_ty_261 =
    _bindgen_ty_261::GDK_VISUAL_DIRECT_COLOR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_261 {
    GDK_VISUAL_STATIC_GRAY = 0,
    GDK_VISUAL_GRAYSCALE = 1,
    GDK_VISUAL_STATIC_COLOR = 2,
    GDK_VISUAL_PSEUDO_COLOR = 3,
    GDK_VISUAL_TRUE_COLOR = 4,
    GDK_VISUAL_DIRECT_COLOR = 5,
}
pub use self::_bindgen_ty_261 as GdkVisualType;
pub const GTK_WIN_POS_NONE: _bindgen_ty_302 =
    _bindgen_ty_302::GTK_WIN_POS_NONE;
pub const GTK_WIN_POS_CENTER: _bindgen_ty_302 =
    _bindgen_ty_302::GTK_WIN_POS_CENTER;
pub const GTK_WIN_POS_MOUSE: _bindgen_ty_302 =
    _bindgen_ty_302::GTK_WIN_POS_MOUSE;
pub const GTK_WIN_POS_CENTER_ALWAYS: _bindgen_ty_302 =
    _bindgen_ty_302::GTK_WIN_POS_CENTER_ALWAYS;
pub const GTK_WIN_POS_CENTER_ON_PARENT: _bindgen_ty_302 =
    _bindgen_ty_302::GTK_WIN_POS_CENTER_ON_PARENT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_302 {
    GTK_WIN_POS_NONE = 0,
    GTK_WIN_POS_CENTER = 1,
    GTK_WIN_POS_MOUSE = 2,
    GTK_WIN_POS_CENTER_ALWAYS = 3,
    GTK_WIN_POS_CENTER_ON_PARENT = 4,
}
pub use self::_bindgen_ty_302 as GtkWindowPosition;
pub const GTK_WINDOW_TOPLEVEL: _bindgen_ty_303 =
    _bindgen_ty_303::GTK_WINDOW_TOPLEVEL;
pub const GTK_WINDOW_POPUP: _bindgen_ty_303 =
    _bindgen_ty_303::GTK_WINDOW_POPUP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_303 { GTK_WINDOW_TOPLEVEL = 0, GTK_WINDOW_POPUP = 1, }
pub use self::_bindgen_ty_303 as GtkWindowType;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkObject {
    pub parent_instance: GInitiallyUnowned,
    pub flags: guint32,
}
#[test]
fn bindgen_test_layout__GtkObject() {
    assert_eq!(::std::mem::size_of::<_GtkObject>() , 32usize);
    assert_eq!(::std::mem::align_of::<_GtkObject>() , 8usize);
}
impl Clone for _GtkObject {
    fn clone(&self) -> Self { *self }
}
pub use self::_GtkObject as GtkObject;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkStyle {
    pub parent_instance: GObject,
    pub fg: [GdkColor; 5usize],
    pub bg: [GdkColor; 5usize],
    pub light: [GdkColor; 5usize],
    pub dark: [GdkColor; 5usize],
    pub mid: [GdkColor; 5usize],
    pub text: [GdkColor; 5usize],
    pub base: [GdkColor; 5usize],
    pub text_aa: [GdkColor; 5usize],
    pub black: GdkColor,
    pub white: GdkColor,
    pub font_desc: *mut PangoFontDescription,
    pub xthickness: gint,
    pub ythickness: gint,
    pub fg_gc: [*mut GdkGC; 5usize],
    pub bg_gc: [*mut GdkGC; 5usize],
    pub light_gc: [*mut GdkGC; 5usize],
    pub dark_gc: [*mut GdkGC; 5usize],
    pub mid_gc: [*mut GdkGC; 5usize],
    pub text_gc: [*mut GdkGC; 5usize],
    pub base_gc: [*mut GdkGC; 5usize],
    pub text_aa_gc: [*mut GdkGC; 5usize],
    pub black_gc: *mut GdkGC,
    pub white_gc: *mut GdkGC,
    pub bg_pixmap: [*mut GdkPixmap; 5usize],
    pub attach_count: gint,
    pub depth: gint,
    pub colormap: *mut GdkColormap,
    pub private_font: *mut GdkFont,
    pub private_font_desc: *mut PangoFontDescription,
    pub rc_style: *mut GtkRcStyle,
    pub styles: *mut GSList,
    pub property_cache: *mut GArray,
    pub icon_factories: *mut GSList,
}
#[test]
fn bindgen_test_layout__GtkStyle() {
    assert_eq!(::std::mem::size_of::<_GtkStyle>() , 984usize);
    assert_eq!(::std::mem::align_of::<_GtkStyle>() , 8usize);
}
impl Clone for _GtkStyle {
    fn clone(&self) -> Self { *self }
}
pub use self::_GtkStyle as GtkStyle;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkRcStyle {
    pub parent_instance: GObject,
    pub name: *mut gchar,
    pub bg_pixmap_name: [*mut gchar; 5usize],
    pub font_desc: *mut PangoFontDescription,
    pub color_flags: [GtkRcFlags; 5usize],
    pub fg: [GdkColor; 5usize],
    pub bg: [GdkColor; 5usize],
    pub text: [GdkColor; 5usize],
    pub base: [GdkColor; 5usize],
    pub xthickness: gint,
    pub ythickness: gint,
    pub rc_properties: *mut GArray,
    pub rc_style_lists: *mut GSList,
    pub icon_factories: *mut GSList,
    pub _bitfield_1: u8,
}
#[test]
fn bindgen_test_layout__GtkRcStyle() {
    assert_eq!(::std::mem::size_of::<_GtkRcStyle>() , 384usize);
    assert_eq!(::std::mem::align_of::<_GtkRcStyle>() , 8usize);
}
impl Clone for _GtkRcStyle {
    fn clone(&self) -> Self { *self }
}
impl _GtkRcStyle {
    #[inline]
    pub fn engine_specified(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u8)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_engine_specified(&mut self, val: guint) {
        self._bitfield_1 &= !(1usize as u8);
        self._bitfield_1 |= ((val as u32 as u8) << 0u32) & (1usize as u8);
    }
}
pub use self::_GtkRcStyle as GtkRcStyle;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkWidget {
    pub object: GtkObject,
    pub private_flags: guint16,
    pub state: guint8,
    pub saved_state: guint8,
    pub name: *mut gchar,
    pub style: *mut GtkStyle,
    pub requisition: GtkRequisition,
    pub allocation: GtkAllocation,
    pub window: *mut GdkWindow,
    pub parent: *mut GtkWidget,
}
#[test]
fn bindgen_test_layout__GtkWidget() {
    assert_eq!(::std::mem::size_of::<_GtkWidget>() , 96usize);
    assert_eq!(::std::mem::align_of::<_GtkWidget>() , 8usize);
}
impl Clone for _GtkWidget {
    fn clone(&self) -> Self { *self }
}
pub use self::_GtkWidget as GtkWidget;
pub const GTK_RC_FG: _bindgen_ty_322 = _bindgen_ty_322::GTK_RC_FG;
pub const GTK_RC_BG: _bindgen_ty_322 = _bindgen_ty_322::GTK_RC_BG;
pub const GTK_RC_TEXT: _bindgen_ty_322 = _bindgen_ty_322::GTK_RC_TEXT;
pub const GTK_RC_BASE: _bindgen_ty_322 = _bindgen_ty_322::GTK_RC_BASE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_322 {
    GTK_RC_FG = 1,
    GTK_RC_BG = 2,
    GTK_RC_TEXT = 4,
    GTK_RC_BASE = 8,
}
pub use self::_bindgen_ty_322 as GtkRcFlags;
/**
 * GtkRequisition:
 * @width: the widget's desired width
 * @height: the widget's desired height
 *
 * A <structname>GtkRequisition</structname> represents the desired size of a widget. See
 * <xref linkend="size-requisition"/> for more information.
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkRequisition {
    pub width: gint,
    pub height: gint,
}
#[test]
fn bindgen_test_layout__GtkRequisition() {
    assert_eq!(::std::mem::size_of::<_GtkRequisition>() , 8usize);
    assert_eq!(::std::mem::align_of::<_GtkRequisition>() , 4usize);
}
impl Clone for _GtkRequisition {
    fn clone(&self) -> Self { *self }
}
pub use self::_GtkRequisition as GtkRequisition;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkWindow {
    pub bin: GtkBin,
    pub title: *mut gchar,
    pub wmclass_name: *mut gchar,
    pub wmclass_class: *mut gchar,
    pub wm_role: *mut gchar,
    pub focus_widget: *mut GtkWidget,
    pub default_widget: *mut GtkWidget,
    pub transient_parent: *mut GtkWindow,
    pub geometry_info: *mut GtkWindowGeometryInfo,
    pub frame: *mut GdkWindow,
    pub group: *mut GtkWindowGroup,
    pub configure_request_count: guint16,
    pub _bitfield_1: u32,
    pub frame_left: guint,
    pub frame_top: guint,
    pub frame_right: guint,
    pub frame_bottom: guint,
    pub keys_changed_handler: guint,
    pub mnemonic_modifier: GdkModifierType,
    pub screen: *mut GdkScreen,
}
#[test]
fn bindgen_test_layout__GtkWindow() {
    assert_eq!(::std::mem::size_of::<_GtkWindow>() , 240usize);
    assert_eq!(::std::mem::align_of::<_GtkWindow>() , 8usize);
}
impl Clone for _GtkWindow {
    fn clone(&self) -> Self { *self }
}
impl _GtkWindow {
    #[inline]
    pub fn allow_shrink(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_allow_shrink(&mut self, val: guint) {
        self._bitfield_1 &= !(1usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 0u32) & (1usize as u32);
    }
    #[inline]
    pub fn allow_grow(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (2usize as u32)) >>
                                       1u32) as u32)
        }
    }
    #[inline]
    pub fn set_allow_grow(&mut self, val: guint) {
        self._bitfield_1 &= !(2usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 1u32) & (2usize as u32);
    }
    #[inline]
    pub fn configure_notify_received(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4usize as u32)) >>
                                       2u32) as u32)
        }
    }
    #[inline]
    pub fn set_configure_notify_received(&mut self, val: guint) {
        self._bitfield_1 &= !(4usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 2u32) & (4usize as u32);
    }
    #[inline]
    pub fn need_default_position(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8usize as u32)) >>
                                       3u32) as u32)
        }
    }
    #[inline]
    pub fn set_need_default_position(&mut self, val: guint) {
        self._bitfield_1 &= !(8usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 3u32) & (8usize as u32);
    }
    #[inline]
    pub fn need_default_size(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16usize as u32)) >>
                                       4u32) as u32)
        }
    }
    #[inline]
    pub fn set_need_default_size(&mut self, val: guint) {
        self._bitfield_1 &= !(16usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 4u32) & (16usize as u32);
    }
    #[inline]
    pub fn position(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (224usize as u32)) >>
                                       5u32) as u32)
        }
    }
    #[inline]
    pub fn set_position(&mut self, val: guint) {
        self._bitfield_1 &= !(224usize as u32);
        self._bitfield_1 |= ((val as u32 as u32) << 5u32) & (224usize as u32);
    }
    #[inline]
    pub fn type_(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (3840usize as u32)) >>
                                       8u32) as u32)
        }
    }
    #[inline]
    pub fn set_type(&mut self, val: guint) {
        self._bitfield_1 &= !(3840usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 8u32) & (3840usize as u32);
    }
    #[inline]
    pub fn has_user_ref_count(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (4096usize as u32)) >>
                                       12u32) as u32)
        }
    }
    #[inline]
    pub fn set_has_user_ref_count(&mut self, val: guint) {
        self._bitfield_1 &= !(4096usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 12u32) & (4096usize as u32);
    }
    #[inline]
    pub fn has_focus(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (8192usize as u32)) >>
                                       13u32) as u32)
        }
    }
    #[inline]
    pub fn set_has_focus(&mut self, val: guint) {
        self._bitfield_1 &= !(8192usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 13u32) & (8192usize as u32);
    }
    #[inline]
    pub fn modal(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (16384usize as u32)) >>
                                       14u32) as u32)
        }
    }
    #[inline]
    pub fn set_modal(&mut self, val: guint) {
        self._bitfield_1 &= !(16384usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 14u32) & (16384usize as u32);
    }
    #[inline]
    pub fn destroy_with_parent(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (32768usize as u32)) >>
                                       15u32) as u32)
        }
    }
    #[inline]
    pub fn set_destroy_with_parent(&mut self, val: guint) {
        self._bitfield_1 &= !(32768usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 15u32) & (32768usize as u32);
    }
    #[inline]
    pub fn has_frame(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_has_frame(&mut self, val: guint) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn iconify_initially(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (131072usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_iconify_initially(&mut self, val: guint) {
        self._bitfield_1 &= !(131072usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (131072usize as u32);
    }
    #[inline]
    pub fn stick_initially(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (262144usize as u32))
                                       >> 18u32) as u32)
        }
    }
    #[inline]
    pub fn set_stick_initially(&mut self, val: guint) {
        self._bitfield_1 &= !(262144usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 18u32) & (262144usize as u32);
    }
    #[inline]
    pub fn maximize_initially(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                       >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_maximize_initially(&mut self, val: guint) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn decorated(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                       >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_decorated(&mut self, val: guint) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
    #[inline]
    pub fn type_hint(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (14680064usize as u32))
                                       >> 21u32) as u32)
        }
    }
    #[inline]
    pub fn set_type_hint(&mut self, val: guint) {
        self._bitfield_1 &= !(14680064usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 21u32) & (14680064usize as u32);
    }
    #[inline]
    pub fn gravity(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (520093696usize as u32)) >> 24u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_gravity(&mut self, val: guint) {
        self._bitfield_1 &= !(520093696usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 24u32) & (520093696usize as u32);
    }
    #[inline]
    pub fn is_active(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (536870912usize as u32)) >> 29u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_is_active(&mut self, val: guint) {
        self._bitfield_1 &= !(536870912usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 29u32) & (536870912usize as u32);
    }
    #[inline]
    pub fn has_toplevel_focus(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 &
                                        (1073741824usize as u32)) >> 30u32) as
                                      u32)
        }
    }
    #[inline]
    pub fn set_has_toplevel_focus(&mut self, val: guint) {
        self._bitfield_1 &= !(1073741824usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 30u32) & (1073741824usize as u32);
    }
}
pub use self::_GtkWindow as GtkWindow;
/**
 * GtkAllocation:
 * @x: the X position of the widget's area relative to its parents allocation.
 * @y: the Y position of the widget's area relative to its parents allocation.
 * @width: the width of the widget's allocated area.
 * @height: the height of the widget's allocated area.
 *
 * A <structname>GtkAllocation</structname> of a widget represents region which has been allocated to the
 * widget by its parent. It is a subregion of its parents allocation. See
 * <xref linkend="size-allocation"/> for more information.
 */
pub use self::GdkRectangle as GtkAllocation;
extern "C" {
    pub fn gtk_widget_show_all(widget: *mut GtkWidget);
}
extern "C" {
    pub fn gtk_widget_get_window(widget: *mut GtkWidget) -> *mut GdkWindow;
}
extern "C" {
    pub fn gtk_widget_get_allocation(widget: *mut GtkWidget,
                                     allocation: *mut GtkAllocation);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkContainer {
    pub widget: GtkWidget,
    pub focus_child: *mut GtkWidget,
    pub _bitfield_1: u32,
}
#[test]
fn bindgen_test_layout__GtkContainer() {
    assert_eq!(::std::mem::size_of::<_GtkContainer>() , 112usize);
    assert_eq!(::std::mem::align_of::<_GtkContainer>() , 8usize);
}
impl Clone for _GtkContainer {
    fn clone(&self) -> Self { *self }
}
impl _GtkContainer {
    #[inline]
    pub fn border_width(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65535usize as u32)) >>
                                       0u32) as u32)
        }
    }
    #[inline]
    pub fn set_border_width(&mut self, val: guint) {
        self._bitfield_1 &= !(65535usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 0u32) & (65535usize as u32);
    }
    #[inline]
    pub fn need_resize(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (65536usize as u32)) >>
                                       16u32) as u32)
        }
    }
    #[inline]
    pub fn set_need_resize(&mut self, val: guint) {
        self._bitfield_1 &= !(65536usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 16u32) & (65536usize as u32);
    }
    #[inline]
    pub fn resize_mode(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (393216usize as u32))
                                       >> 17u32) as u32)
        }
    }
    #[inline]
    pub fn set_resize_mode(&mut self, val: guint) {
        self._bitfield_1 &= !(393216usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 17u32) & (393216usize as u32);
    }
    #[inline]
    pub fn reallocate_redraws(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (524288usize as u32))
                                       >> 19u32) as u32)
        }
    }
    #[inline]
    pub fn set_reallocate_redraws(&mut self, val: guint) {
        self._bitfield_1 &= !(524288usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 19u32) & (524288usize as u32);
    }
    #[inline]
    pub fn has_focus_chain(&self) -> guint {
        unsafe {
            ::std::mem::transmute(((self._bitfield_1 & (1048576usize as u32))
                                       >> 20u32) as u32)
        }
    }
    #[inline]
    pub fn set_has_focus_chain(&mut self, val: guint) {
        self._bitfield_1 &= !(1048576usize as u32);
        self._bitfield_1 |=
            ((val as u32 as u32) << 20u32) & (1048576usize as u32);
    }
}
pub use self::_GtkContainer as GtkContainer;
extern "C" {
    pub fn gtk_container_add(container: *mut GtkContainer,
                             widget: *mut GtkWidget);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkBin {
    pub container: GtkContainer,
    pub child: *mut GtkWidget,
}
#[test]
fn bindgen_test_layout__GtkBin() {
    assert_eq!(::std::mem::size_of::<_GtkBin>() , 120usize);
    assert_eq!(::std::mem::align_of::<_GtkBin>() , 8usize);
}
impl Clone for _GtkBin {
    fn clone(&self) -> Self { *self }
}
pub use self::_GtkBin as GtkBin;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkWindowGeometryInfo {
    pub _address: u8,
}
impl Clone for _GtkWindowGeometryInfo {
    fn clone(&self) -> Self { *self }
}
pub use self::_GtkWindowGeometryInfo as GtkWindowGeometryInfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _GtkWindowGroup {
    pub parent_instance: GObject,
    pub grabs: *mut GSList,
}
#[test]
fn bindgen_test_layout__GtkWindowGroup() {
    assert_eq!(::std::mem::size_of::<_GtkWindowGroup>() , 32usize);
    assert_eq!(::std::mem::align_of::<_GtkWindowGroup>() , 8usize);
}
impl Clone for _GtkWindowGroup {
    fn clone(&self) -> Self { *self }
}
pub use self::_GtkWindowGroup as GtkWindowGroup;
extern "C" {
    pub fn gtk_window_new(type_: GtkWindowType) -> *mut GtkWidget;
}
extern "C" {
    pub fn gtk_window_set_title(window: *mut GtkWindow, title: *const gchar);
}
extern "C" {
    pub fn gtk_window_set_position(window: *mut GtkWindow,
                                   position: GtkWindowPosition);
}
extern "C" {
    pub fn gtk_window_set_default_size(window: *mut GtkWindow, width: gint,
                                       height: gint);
}
extern "C" {
    pub fn gtk_vbox_new(homogeneous: gboolean, spacing: gint)
     -> *mut GtkWidget;
}
extern "C" {
    pub fn gtk_init(argc: *mut ::std::os::raw::c_int,
                    argv: *mut *mut *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn gtk_main();
}
pub type XID = ::std::os::raw::c_ulong;
extern "C" {
    pub fn gdk_x11_drawable_get_xid(drawable: *mut GdkDrawable) -> XID;
}
